PROG -> <var_in_program=0;> program { DESCR OP }

DESCR -> DESCR1 ; DESCR | eps
DESCR1 -> int <is_real=is_string=false; is_int=false> VAR VAR1 | string <is_real=is_int=false; is_string=true> VAR VAR1 | real <is_int=is_string=false; is_real=false> VAR VAR1 
VAR1 -> , VAR VAR1 | eps
VAR -> identifier <declare();> VAR2
VAR2 -> = CONST1 | eps
CONST1 -> +creal <проверка типов> | -creal <проверка типов> | +cint <проверка типов> | -cint <проверка типов> | cstring <проверка типов> | cint <проверка типов> | creal <проверка типов>

OP (statement) -> OP1 <st_lex.reset();> OP | eps;
OP1 -> IFELSE | WHILE | FOR | READ | WRITE | COMPLEXOP | EXPRESSIONOP | continue ;
IFELSE -> if ( EXPR ) OP1 else OP1
WHILE -> while ( EXPR ) OP1
READ -> read ( ident <check_id();> ) ;
WRITE -> write ( EXPR WRITE1 ) ;
WRITE1 -> , EXPR WRITE1 | eps
COMPLEXOP -> { OP }
EXPRESSIONOP -> EXPR ;
FOR -> for ( FOR1 ; FOR1 ; FOR1 ) OP1
FOR1 -> EXPR | eps                    // ВАЖНО: из EXPR не выводится eps 
CONTINUE -> continue ;

EXPR -> EXPR1 EXPR11
EXPR11 -> =  EXPR1 EXPR11 | eps // видимо для выражений с "=" нужна своя проверка операндов // done
EXPR1 -> EXPR2 EXPROR
EXPROR -> or <st_lex.push(curr_lex);>EXPR2 <check_op();> EXPROR | eps
EXPR2 -> EXPR3 EXPRAND
EXPRAND -> and <st_lex.push(curr_lex);> EXPR3 <check_op();> EXPRAND | eps
EXPR3 -> EXPR4 EXPR41
EXPR41 -> < <st_lex.push(curr_lex);> EXPR4 <check_op();> EXPR41 | > ... EXPR4 ... | <= ... EXPR4 ... | >= ... EXPR4 ... | == ... EXPR4 ... | != ... EXPR4 ...  // тут немножко переделано 
EXPR4 -> EXPR5 EXPR51
EXPR51 -> + <st_lex.push(curr_lex);> EXPR5 <check_op();> EXPR51 | - <st_lex.push(curr_lex);> EXPR5 <check_op();> EXPR51 | eps
EXPR5 -> EXPR6 EXPR61
EXPR61 -> * <st_lex.push(curr_lex);> EXPR6 <check_op();> EXPR61 | / <st_lex.push(curr_lex);> EXPR6 <check_op();> EXPR61 | eps
EXPR6 -> not <st_lex.push(curr_lex);> EXPR6 <check_not();> | - <st_lex.push(curr_lex);> EXPR6 <check_unary_op();> | + <st_lex.push(curr_lex);> EXPR6 <check_unary_op();> | EXPR7
EXPR7 -> ident <check_id(); <st_lex.push(curr_lex);> | creal <st_lex.push(curr_lex);> | cint <st_lex.push(curr_lex);> | cstring <st_lex.push(curr_lex);>| (EXPR)



Проверка соответствия типов выражения осуществляется следующим образом:
1) По мере прохождения грамматики для EXPR РС методом заполняется стек (<st_lex.push(curr_lex);>)
2) При встрече команды <check_op();> из стека вытаскиваются три верхних ячейки и проверяется соответствие типов
3) Если конфликта типов не обнаружено, то в стек кладётся тип результата выражения (Например, результат выражения 23.5>13 имеет тип LEX_CINT, результат выражения x=y имеет тип такой же, какой имеет х) 
4) Аналогично проверяются унарные операции (<check_not();> и <check_unary_op();>)

У операторов if else, while, read, write, for свои функции проверки типов 

Для унарных плюса и минуса нужно сделать отдельные типы (при помещении в ПОЛИЗ).